# to re-scale the CPM data before computing the average gene expression.
B <- bseqsc_basis(eislet, pancreasMarkers, clusters = 'cellType',
samples = 'sampleID', ct.scale = TRUE)
#The resulting basis matrix should show a clear cell type-specific
# expression pattern (Figure 2):
#plotBasis(B, pancreasMarkers, Colv = NA, Rowv = NA, layout = '_', col = 'Blues')
# Cell type proportions are estimated using CIBERSORT, a method that was developed to
# investigate immune infiltrating landscape in tumour tissue
fit <- bseqsc_proportions(eset, B, verbose = TRUE)
fit$coefficients
#To facilitate plotting and model fitting in downstream analysis,
#we add the estimated proportions as extra phenotypic variables to
#the ExpressionSet:
pData(eset) <- cbind(pData(eset), t(coef(fit)))
eset@phenoData@data
proportions <- as.numeric(c(eset$alpha, eset$beta, eset$acinar, eset$ductal, eset$gamma, eset$delta))
cell_types <- c(rep("alpha", 20), rep("beta", 20), rep("acinar", 20),
rep("ductal", 20), rep("gamma", 20), rep("delta", 20))
cell_types = factor(cell_types, levels <- c("gamma", "delta", "beta", "alpha", "ductal",
"acinar"))
#state <- rep(eset$hba1c_class2, 6)
#sample <- rep(eset$geo_accession, 6)
sample <- rep(rownames(eset@phenoData@data), 6)
sample <- factor(sample, levels = c("MIX_1", "MIX_2", "MIX_3", "MIX_4", "MIX_5",
"MIX_6", "MIX_7", "MIX_8", "MIX_9", "MIX_10",
"MIX_11", "MIX_12", "MIX_13", "MIX_14", "MIX_15",
"MIX_16", "MIX_17", "MIX_18", "MIX_19", "MIX_20"))
plot_df <- data.frame(sample, cell_types, proportions)
ourEstimated<-ggplot(plot_df, aes(sample, proportions, fill = cell_types)) +
stat_summary(fun.y = "mean", geom = "bar", position = "fill") +
scale_fill_manual(values = c("green", "orange", "purple", "turquoise3", "yellow", "red")) +
theme(axis.text.x = element_text(angle = 90, size = 7)) +
ggtitle("Estimated Proportions")
actual_mix <- read.csv("actual_mix.txt", header = TRUE, sep='\t')
actual_mat <- data.matrix(actual_mix[,-1])
rownames(actual_mat) <- actual_mix$Sample
actual_df <- data.frame(actual_mat)
proportions <- as.numeric(c(actual_df$alpha, actual_df$beta, actual_df$Acinar,
actual_df$Ductal, actual_df$gamma, actual_df$delta))
cell_types <- c(rep("alpha", 20), rep("beta", 20), rep("acinar", 20),
rep("ductal", 20), rep("gamma", 20), rep("delta", 20))
cell_types = factor(cell_types, levels <- c("gamma", "delta", "beta", "alpha", "ductal",
"acinar"))
sample <- rep(rownames(actual_df), 6)
sample <- factor(sample, levels = c("MIX1", "MIX2", "MIX3", "MIX4", "MIX5",
"MIX6", "MIX7", "MIX8", "MIX9", "MIX10",
"MIX11", "MIX12", "MIX13", "MIX14", "MIX15",
"MIX16", "MIX17", "MIX18", "MIX19", "MIX20"))
actual_plot_df <- data.frame(sample, cell_types, proportions)
ourActual<-ggplot(actual_plot_df, aes(sample, proportions, fill = cell_types)) +
stat_summary(fun.y = "mean", geom = "bar", position = "fill") +
scale_fill_manual(values = c("green", "orange", "purple", "turquoise3", "yellow", "red")) +
theme(axis.text.x = element_text(angle = 90, size = 7)) +
ggtitle("Actual Proportions")
corr_df <- data.frame(samples=actual_plot_df$sample,
cell_types=actual_plot_df$cell_types,
actualP=actual_plot_df$proportions,
estimatedP=plot_df$proportions)
corr_df$cell_types = factor(corr_df$cell_types, levels = c("acinar",
"ductal",
"alpha",
"beta",
"delta",
"gamma"))
r <- by(corr_df, corr_df$cell_types, FUN = function(X) cor(X$estimatedP, X$actualP, method = "pearson"))
r2 <- data.frame(group = dimnames(r)[[1]], corr = as.vector(r))
corr_df$r2 <- rep(r2$corr, each = 20)
corr_df$cell_r2 <- paste(corr_df$cell_types, round(corr_df$r2, 3), sep="_")
table(corr_df$cell_r2)
corr_df$cell_r2 = factor(corr_df$cell_r2, levels = c("acinar_0.903",
"ductal_0.933",
"alpha_0.957",
"beta_0.89",
"delta_0.999",
"gamma_0.935"))
our_corr_plot <- ggplot(corr_df, aes(actualP, estimatedP, color = cell_r2)) +
stat_summary(fun.y = "mean", geom = "point") +
geom_smooth(method='lm', alpha = 0.1) +
scale_color_manual(values = c("red", "yellow", "turquoise3", "purple",
"orange", "green"))
our_corr_plot
# Emily's 20 mixtures (simulated bulk rna)
ee <- fread("20_MIXTURES.txt", header = TRUE)
e2 <- data.matrix(ee[,-1])
new_genes <- make.unique(ee$Gene)
rownames(e2) <- new_genes
eset <- ExpressionSet(assayData = e2)
## single cells
eislet <- readRDS('~/Desktop/Itai/bseqsc_test/shiny_bseqsc/bseqsc/islet-eset.rds')
eislet
# The bseqsc package provides the list of selected marker genes for
# the pancreatic islets, stored in data object pancreasMarkers:
data(pancreasMarkers)
str(pancreasMarkers)
# average counts computed within each cell type in each sample
#plotCellTotals(eislet, 'cellType', 'sampleID')
# Because we want the basis matrix of reference profiles to
# reflect these biological differences, we use these average counts
# to re-scale the CPM data before computing the average gene expression.
B <- bseqsc_basis(eislet, pancreasMarkers, clusters = 'cellType',
samples = 'sampleID', ct.scale = TRUE)
#The resulting basis matrix should show a clear cell type-specific
# expression pattern (Figure 2):
#plotBasis(B, pancreasMarkers, Colv = NA, Rowv = NA, layout = '_', col = 'Blues')
# Cell type proportions are estimated using CIBERSORT, a method that was developed to
# investigate immune infiltrating landscape in tumour tissue
fit <- bseqsc_proportions(eset, B, verbose = TRUE)
fit$coefficients
#To facilitate plotting and model fitting in downstream analysis,
#we add the estimated proportions as extra phenotypic variables to
#the ExpressionSet:
pData(eset) <- cbind(pData(eset), t(coef(fit)))
eset@phenoData@data
proportions <- as.numeric(c(eset$alpha, eset$beta, eset$acinar, eset$ductal, eset$gamma, eset$delta))
cell_types <- c(rep("alpha", 20), rep("beta", 20), rep("acinar", 20),
rep("ductal", 20), rep("gamma", 20), rep("delta", 20))
cell_types = factor(cell_types, levels <- c("gamma", "delta", "beta", "alpha", "ductal",
"acinar"))
#state <- rep(eset$hba1c_class2, 6)
#sample <- rep(eset$geo_accession, 6)
sample <- rep(rownames(eset@phenoData@data), 6)
sample <- factor(sample, levels = c("MIX_1", "MIX_2", "MIX_3", "MIX_4", "MIX_5",
"MIX_6", "MIX_7", "MIX_8", "MIX_9", "MIX_10",
"MIX_11", "MIX_12", "MIX_13", "MIX_14", "MIX_15",
"MIX_16", "MIX_17", "MIX_18", "MIX_19", "MIX_20"))
plot_df <- data.frame(sample, cell_types, proportions)
ourEstimated<-ggplot(plot_df, aes(sample, proportions, fill = cell_types)) +
stat_summary(fun.y = "mean", geom = "bar", position = "fill") +
scale_fill_manual(values = c("green", "orange", "purple", "turquoise3", "yellow", "red")) +
theme(axis.text.x = element_text(angle = 90, size = 7)) +
ggtitle("Estimated Proportions")
actual_mix <- read.csv("actual_mix.txt", header = TRUE, sep='\t')
actual_mat <- data.matrix(actual_mix[,-1])
rownames(actual_mat) <- actual_mix$Sample
actual_df <- data.frame(actual_mat)
proportions <- as.numeric(c(actual_df$alpha, actual_df$beta, actual_df$Acinar,
actual_df$Ductal, actual_df$gamma, actual_df$delta))
cell_types <- c(rep("alpha", 20), rep("beta", 20), rep("acinar", 20),
rep("ductal", 20), rep("gamma", 20), rep("delta", 20))
cell_types = factor(cell_types, levels <- c("gamma", "delta", "beta", "alpha", "ductal",
"acinar"))
sample <- rep(rownames(actual_df), 6)
sample <- factor(sample, levels = c("MIX1", "MIX2", "MIX3", "MIX4", "MIX5",
"MIX6", "MIX7", "MIX8", "MIX9", "MIX10",
"MIX11", "MIX12", "MIX13", "MIX14", "MIX15",
"MIX16", "MIX17", "MIX18", "MIX19", "MIX20"))
actual_plot_df <- data.frame(sample, cell_types, proportions)
ourActual<-ggplot(actual_plot_df, aes(sample, proportions, fill = cell_types)) +
stat_summary(fun.y = "mean", geom = "bar", position = "fill") +
scale_fill_manual(values = c("green", "orange", "purple", "turquoise3", "yellow", "red")) +
theme(axis.text.x = element_text(angle = 90, size = 7)) +
ggtitle("Actual Proportions")
pdf("emily_6cell_repeat.pdf", height = 10)
grid.arrange(ourActual, ourEstimated, ncol = 1)
dev.off()
#### corr plot
corr_df <- data.frame(samples=actual_plot_df$sample,
cell_types=actual_plot_df$cell_types,
actualP=actual_plot_df$proportions,
estimatedP=plot_df$proportions)
corr_df$cell_types = factor(corr_df$cell_types, levels = c("acinar",
"ductal",
"alpha",
"beta",
"delta",
"gamma"))
r <- by(corr_df, corr_df$cell_types, FUN = function(X) cor(X$estimatedP, X$actualP, method = "pearson"))
r2 <- data.frame(group = dimnames(r)[[1]], corr = as.vector(r))
corr_df$r2 <- rep(r2$corr, each = 20)
corr_df$cell_r2 <- paste(corr_df$cell_types, round(corr_df$r2, 3), sep="_")
table(corr_df$cell_r2)
corr_df$cell_r2 = factor(corr_df$cell_r2, levels = c("acinar_0.903",
"ductal_0.933",
"alpha_0.957",
"beta_0.89",
"delta_0.999",
"gamma_0.935"))
# dat_labels <- corr_df %>% group_by(cell_types) %>% summarise(
#   label_y=max(estimatedP),
#   label_value=max(r2),
#   label_x=max(actualP)
# )
our_corr_plot <- ggplot(corr_df, aes(actualP, estimatedP, color = cell_r2)) +
stat_summary(fun.y = "mean", geom = "point") +
geom_smooth(method='lm', alpha = 0.1) +
scale_color_manual(values = c("red", "yellow", "turquoise3", "purple",
"orange", "green"))
pdf("emily_6cell_corr_ourMarkers.pdf", width = 10)
our_corr_plot
dev.off()
###### shared markers?
### CLEAR WORKSPACE
# Emily's 20 mixtures (simulated bulk rna)
ee <- fread("20_MIXTURES.txt", header = TRUE)
e2 <- data.matrix(ee[,-1])
new_genes <- make.unique(ee$Gene)
rownames(e2) <- new_genes
eset <- ExpressionSet(assayData = e2)
## single cells
eislet <- readRDS('~/Desktop/Itai/bseqsc_test/shiny_bseqsc/bseqsc/islet-eset.rds')
eislet
# data(pancreasMarkers)
# str(pancreasMarkers)
# class(pancreasMarkers)
alpha_marks <- c("GCG", "TTR", "IRX2", "TM4SF4", "RGS4", "KCTD12", "CRYBA2", "PDK4", "PCSK2")
beta_marks <- c("INS", "IAPP", "DLK1", "PDX1", "ADCYAP1", "HADH")
delta_marks <- c("SST", "LEPR", "RBP4", "RGS2", "SEC11C")
gamma_marks <- c("PPY", "MEIS2", "AQP3")
acinar_marks <- c("CTRB1", "CELA3A", "CTRB2", "PLA2G1B", "SPINK1", "CLPS", "CPA1",
"PRSS1", "CPA2", "REG1A", "PNLIP", "CTRC", "CELA2A", "CPB1")
ductal_marks <- c("KRT19")
sharedMarkers<- list(alpha=alpha_marks, beta=beta_marks, delta=delta_marks,
gamma=gamma_marks, acinar=acinar_marks,
ductal=ductal_marks)
# average counts computed within each cell type in each sample
#plotCellTotals(eislet, 'cellType', 'sampleID')
# Because we want the basis matrix of reference profiles to
# reflect these biological differences, we use these average counts
# to re-scale the CPM data before computing the average gene expression.
B <- bseqsc_basis(eislet, sharedMarkers, clusters = 'cellType',
samples = 'sampleID', ct.scale = TRUE)
#The resulting basis matrix should show a clear cell type-specific
# expression pattern (Figure 2):
#plotBasis(B, sharedMarkers, Colv = NA, Rowv = NA, layout = '_', col = 'Blues')
# Cell type proportions are estimated using CIBERSORT, a method that was developed to
# investigate immune infiltrating landscape in tumour tissue
fit <- bseqsc_proportions(eset, B, verbose = TRUE)
#fit$coefficients
#To facilitate plotting and model fitting in downstream analysis,
#we add the estimated proportions as extra phenotypic variables to
#the ExpressionSet:
pData(eset) <- cbind(pData(eset), t(coef(fit)))
eset@phenoData@data
proportions <- as.numeric(c(eset$alpha, eset$beta, eset$acinar, eset$ductal, eset$gamma, eset$delta))
cell_types <- c(rep("alpha", 20), rep("beta", 20), rep("acinar", 20),
rep("ductal", 20), rep("gamma", 20), rep("delta", 20))
cell_types = factor(cell_types, levels <- c("gamma", "delta", "beta", "alpha", "ductal",
"acinar"))
#state <- rep(eset$hba1c_class2, 6)
#sample <- rep(eset$geo_accession, 6)
sample <- rep(rownames(eset@phenoData@data), 6)
sample <- factor(sample, levels = c("MIX_1", "MIX_2", "MIX_3", "MIX_4", "MIX_5",
"MIX_6", "MIX_7", "MIX_8", "MIX_9", "MIX_10",
"MIX_11", "MIX_12", "MIX_13", "MIX_14", "MIX_15",
"MIX_16", "MIX_17", "MIX_18", "MIX_19", "MIX_20"))
plot_df <- data.frame(sample, cell_types, proportions)
shareEstimated<-ggplot(plot_df, aes(sample, proportions, fill = cell_types)) +
stat_summary(fun.y = "mean", geom = "bar", position = "fill") +
scale_fill_manual(values = c("green", "orange", "purple", "turquoise3", "yellow", "red")) +
theme(axis.text.x = element_text(angle = 90, size = 7)) +
ggtitle("Estimated Proportions")
actual_mix <- read.csv("actual_mix.txt", header = TRUE, sep='\t')
actual_mat <- data.matrix(actual_mix[,-1])
rownames(actual_mat) <- actual_mix$Sample
actual_df <- data.frame(actual_mat)
proportions <- as.numeric(c(actual_df$alpha, actual_df$beta, actual_df$Acinar,
actual_df$Ductal, actual_df$gamma, actual_df$delta))
cell_types <- c(rep("alpha", 20), rep("beta", 20), rep("acinar", 20),
rep("ductal", 20), rep("gamma", 20), rep("delta", 20))
cell_types = factor(cell_types, levels <- c("gamma", "delta", "beta", "alpha", "ductal",
"acinar"))
sample <- rep(rownames(actual_df), 6)
sample <- factor(sample, levels = c("MIX1", "MIX2", "MIX3", "MIX4", "MIX5",
"MIX6", "MIX7", "MIX8", "MIX9", "MIX10",
"MIX11", "MIX12", "MIX13", "MIX14", "MIX15",
"MIX16", "MIX17", "MIX18", "MIX19", "MIX20"))
actual_plot_df <- data.frame(sample, cell_types, proportions)
shareActual<-ggplot(actual_plot_df, aes(sample, proportions, fill = cell_types)) +
stat_summary(fun.y = "mean", geom = "bar", position = "fill") +
scale_fill_manual(values = c("green", "orange", "purple", "turquoise3", "yellow", "red")) +
theme(axis.text.x = element_text(angle = 90, size = 7)) +
ggtitle("Actual Proportions")
pdf("emily_6cell_repeat_sharedMarkers.pdf", height = 10)
grid.arrange(shareActual, shareEstimated, ncol = 1)
dev.off()
#### corr plot
corr_df <- data.frame(samples=actual_plot_df$sample,
cell_types=actual_plot_df$cell_types,
actualP=actual_plot_df$proportions,
estimatedP=plot_df$proportions)
corr_df$cell_types = factor(corr_df$cell_types, levels = c("acinar",
"ductal",
"alpha",
"beta",
"delta",
"gamma"))
r <- by(corr_df, corr_df$cell_types, FUN = function(X) cor(X$estimatedP, X$actualP, method = "pearson"))
r2 <- data.frame(group = dimnames(r)[[1]], corr = as.vector(r))
corr_df$r2 <- rep(r2$corr, each = 20)
corr_df$cell_r2 <- paste(corr_df$cell_types, round(corr_df$r2, 3), sep="_")
table(corr_df$cell_r2)
corr_df$cell_r2 = factor(corr_df$cell_r2, levels = c("acinar_0.859",
"ductal_0.934",
"alpha_0.923",
"beta_0.81",
"delta_0.999",
"gamma_0.884"))
# dat_labels <- corr_df %>% group_by(cell_types) %>% summarise(
#   label_y=max(estimatedP),
#   label_value=max(r2),
#   label_x=max(actualP)
# )
share_corr_plot <- ggplot(corr_df, aes(actualP, estimatedP, color = cell_r2)) +
stat_summary(fun.y = "mean", geom = "point") +
geom_smooth(method='lm', alpha = 0.1) +
scale_color_manual(values = c("red", "yellow", "turquoise3", "purple",
"orange", "green"))
pdf("emily_6cell_corr_sharedMarkers.pdf", width = 10)
share_corr_plot
dev.off()
####
###### Their markers
### CLEAR WORKSPACE
# Emily's 20 mixtures (simulated bulk rna)
ee <- fread("20_MIXTURES.txt", header = TRUE)
e2 <- data.matrix(ee[,-1])
new_genes <- make.unique(ee$Gene)
rownames(e2) <- new_genes
eset <- ExpressionSet(assayData = e2)
## single cells
eislet <- readRDS('~/Desktop/Itai/bseqsc_test/shiny_bseqsc/bseqsc/islet-eset.rds')
eislet
# data(pancreasMarkers)
# str(pancreasMarkers)
# class(pancreasMarkers)
alpha_marks <- c("GCG", "TTR", "IRX2", "TM4SF4", "RGS4", "KCTD12", "CRYBA2",
"PDK4", "PCSK2", "ALDH1A1", "ARRDC4", "CHGB", "FAM84A", "FAP",
"FEV", "FSTL5", "GC", "KLHL41", "LOXL4", "PLCE1", "PTPRT",
"SLC38A4", "TMEM236", "VGF")
beta_marks <- c("INS", "IAPP", "DLK1", "PDX1", "ADCYAP1", "HADH",
"CDKN1C", "ENTPD3", "FAM105A", "FAM159B", "LOC154761", "MAFA",
"MAPT", "MEG3", "NPTX2", "PCDH7", "PFKB2", "ROBO2", "SCD5",
"SMAD9", "SORL1", "SRXN1", "SYT13", "TGFBR3", "WSCD2")
delta_marks <- c("SST", "LEPR", "RBP4", "RGS2", "SEC11C",
"AMIGO2", "BCHE", "CALB1", "CBLN4", "CDHR3", "ERBB4", "FHOD3",
"FRZB", "GABRA1", "GABRG2", "GHSR", "HAP1", "HHEX", "LPHN2",
"PCSK1", "PRG4", "SLC17A6", "TENM3")
gamma_marks <- c("PPY", "MEIS2", "AQP3",
"ABCC9", "APOBEC2", "BCYRN1", "CARD11", "CARTPT", "CHN2",
"CHRM3", "EGR3", "ENTPD2", "ETV1", "FGB", "ID2", "INPP5F",
"KCNG1", "LMO3", "PCDH8", "PTGFR", "SERTM1", "SLC6A4", "SLITRK6",
"THSD7A", "TMEM47")
acinar_marks <- c("CTRB1", "CELA3A", "CTRB2", "PLA2G1B", "SPINK1", "CLPS", "CPA1",
"PRSS1", "CPA2", "REG1A", "PNLIP", "CTRC", "CELA2A", "CPB1",
"ALB", "ALDOB", "AMY2A", "CEL", "GP2", "GSTA1", "GSTA2", "PNLIPRP2",
"PRSS3P2", "REG1B", "REG3A")
ductal_marks <- c("KRT19", "ALDH1A3", "ANXA4", "APCDD1", "APCS", "AQP1", "CD74",
"CEACAM6", "CEACAM7", "CFTR", "CLDN1", "CRP", "CXCL6", "DEFB1",
"LGALS4", "MMP7", "ONECUT2", "SERPINA5", "SERPINB2", "SERPING1",
"SLC4A4", "SPP1", "TFPI2", "TSPAN8", "VTCN1")
TheirMarkers<- list(alpha=alpha_marks, beta=beta_marks, delta=delta_marks,
gamma=gamma_marks, acinar=acinar_marks,
ductal=ductal_marks)
# average counts computed within each cell type in each sample
#plotCellTotals(eislet, 'cellType', 'sampleID')
# Because we want the basis matrix of reference profiles to
# reflect these biological differences, we use these average counts
# to re-scale the CPM data before computing the average gene expression.
B <- bseqsc_basis(eislet, TheirMarkers, clusters = 'cellType',
samples = 'sampleID', ct.scale = TRUE)
#The resulting basis matrix should show a clear cell type-specific
# expression pattern (Figure 2):
#plotBasis(B, TheirMarkers, Colv = NA, Rowv = NA, layout = '_', col = 'Blues')
# Cell type proportions are estimated using CIBERSORT, a method that was developed to
# investigate immune infiltrating landscape in tumour tissue
fit <- bseqsc_proportions(eset, B, verbose = TRUE)
#fit$coefficients
#To facilitate plotting and model fitting in downstream analysis,
#we add the estimated proportions as extra phenotypic variables to
#the ExpressionSet:
pData(eset) <- cbind(pData(eset), t(coef(fit)))
#eset@phenoData@data
proportions <- as.numeric(c(eset$alpha, eset$beta, eset$acinar, eset$ductal, eset$gamma, eset$delta))
cell_types <- c(rep("alpha", 20), rep("beta", 20), rep("acinar", 20),
rep("ductal", 20), rep("gamma", 20), rep("delta", 20))
cell_types = factor(cell_types, levels <- c("gamma", "delta", "beta", "alpha", "ductal",
"acinar"))
#state <- rep(eset$hba1c_class2, 6)
#sample <- rep(eset$geo_accession, 6)
sample <- rep(rownames(eset@phenoData@data), 6)
sample <- factor(sample, levels = c("MIX_1", "MIX_2", "MIX_3", "MIX_4", "MIX_5",
"MIX_6", "MIX_7", "MIX_8", "MIX_9", "MIX_10",
"MIX_11", "MIX_12", "MIX_13", "MIX_14", "MIX_15",
"MIX_16", "MIX_17", "MIX_18", "MIX_19", "MIX_20"))
plot_df <- data.frame(sample, cell_types, proportions)
theirEstimated<-ggplot(plot_df, aes(sample, proportions, fill = cell_types)) +
stat_summary(fun.y = "mean", geom = "bar", position = "fill") +
scale_fill_manual(values = c("green", "orange", "purple", "turquoise3", "yellow", "red")) +
theme(axis.text.x = element_text(angle = 90, size = 7)) +
ggtitle("Estimated Proportions")
actual_mix <- read.csv("actual_mix.txt", header = TRUE, sep='\t')
actual_mat <- data.matrix(actual_mix[,-1])
rownames(actual_mat) <- actual_mix$Sample
actual_df <- data.frame(actual_mat)
proportions <- as.numeric(c(actual_df$alpha, actual_df$beta, actual_df$Acinar,
actual_df$Ductal, actual_df$gamma, actual_df$delta))
cell_types <- c(rep("alpha", 20), rep("beta", 20), rep("acinar", 20),
rep("ductal", 20), rep("gamma", 20), rep("delta", 20))
cell_types = factor(cell_types, levels <- c("gamma", "delta", "beta", "alpha", "ductal",
"acinar"))
sample <- rep(rownames(actual_df), 6)
sample <- factor(sample, levels = c("MIX1", "MIX2", "MIX3", "MIX4", "MIX5",
"MIX6", "MIX7", "MIX8", "MIX9", "MIX10",
"MIX11", "MIX12", "MIX13", "MIX14", "MIX15",
"MIX16", "MIX17", "MIX18", "MIX19", "MIX20"))
actual_plot_df <- data.frame(sample, cell_types, proportions)
theirActual<-ggplot(actual_plot_df, aes(sample, proportions, fill = cell_types)) +
stat_summary(fun.y = "mean", geom = "bar", position = "fill") +
scale_fill_manual(values = c("green", "orange", "purple", "turquoise3", "yellow", "red")) +
theme(axis.text.x = element_text(angle = 90, size = 7)) +
ggtitle("Actual Proportions")
pdf("emily_6cell_repeat_theirMarkers.pdf", height = 10)
grid.arrange(theirActual, theirEstimated, ncol = 1)
dev.off()
#### corr plot
corr_df <- data.frame(samples=actual_plot_df$sample,
cell_types=actual_plot_df$cell_types,
actualP=actual_plot_df$proportions,
estimatedP=plot_df$proportions)
corr_df$cell_types = factor(corr_df$cell_types, levels = c("acinar",
"ductal",
"alpha",
"beta",
"delta",
"gamma"))
fits <- lmList(estimatedP ~ actualP | cell_types, data=corr_df)
r <- by(corr_df, corr_df$cell_types, FUN = function(X) cor(X$estimatedP, X$actualP, method = "pearson"))
r2 <- data.frame(group = dimnames(r)[[1]], corr = as.vector(r))
corr_df$r2 <- rep(r2$corr, each = 20)
corr_df$cell_r2 <- paste(corr_df$cell_types, round(corr_df$r2, 3), sep="_")
corr_df$cell_r2 = factor(corr_df$cell_r2, levels = c("acinar_0.901",
"ductal_0.92",
"alpha_0.959",
"beta_0.801",
"delta_0.999",
"gamma_0.939"))
# dat_labels <- corr_df %>% group_by(cell_types) %>% summarise(
#   label_y=max(estimatedP),
#   label_value=max(r2),
#   label_x=max(actualP)
# )
their_corr_plot <- ggplot(corr_df, aes(actualP, estimatedP, color = cell_r2)) +
stat_summary(fun.y = "mean", geom = "point") +
geom_smooth(method='lm', alpha = 0.1) +
scale_color_manual(values = c("red", "yellow", "turquoise3", "purple",
"orange", "green"))
pdf("emily_6cell_corr_theirMarkers.pdf", width = 10)
their_corr_plot
dev.off()
strtrim(c("abcdef", "abcdef", "abcdef"), c(1,5,10))
install.packages("stringr")
library("stringr", lib.loc="/Library/Frameworks/R.framework/Versions/3.4/Resources/library")
x <- c("this_is_the_longest_effing_string_ever")
length(x)
class(x)
x <- "this_is_the_longest_effing_string_ever"
class(x)
length(x)
str_trunc(x, 10, "center")
nchar(x)
shiny::runApp('~/Desktop/Kelly/wham_9.16')
runApp('~/Desktop/Kelly/wham_9.16')
runApp('~/Desktop/Kelly/wham_9.16')
runApp('~/Desktop/Kelly/wham_9.19')
runApp('~/Desktop/Kelly/wham_9.19')
runApp('~/Desktop/Kelly/wham_9.19')
runApp('~/Desktop/Kelly/wham_9.19')
runApp('~/Desktop/Kelly/wham_9.19')
runApp('~/Desktop/Kelly/wham_9.19')
runApp('~/Desktop/Kelly/wham_9.19')
runApp('~/Desktop/Kelly/wham_9.19')
runApp('~/Desktop/Kelly/wham_9.19')
runApp('~/Desktop/Kelly/wham_9.19')
runApp('~/Desktop/Kelly/wham_9.19')
setwd("~/Desktop/Kelly/wham_9.16")
full_file = fread("univ_input.tsv", header=TRUE, sep="\t")
play <- full_file[1:100,]
View(play)
play <- full_file[1:50,]
table(play$Gene_Family)
max(table(play$Gene_Family))
runApp('~/Desktop/Kelly/wham_9.19')
runApp('~/Desktop/Kelly/wham_9.19')
runApp('~/Desktop/Kelly/wham_9.19')
runApp('~/Desktop/Kelly/wham_9.19')
runApp('~/Desktop/Kelly/wham_9.19')
runApp('~/Desktop/Kelly/wham_9.19')
runApp('~/Desktop/Kelly/wham_9.19')
runApp('~/Desktop/Kelly/wham_9.19')
runApp('~/Desktop/Kelly/wham_9.19')
runApp('~/Desktop/Kelly/wham_9.19')
runApp('~/Desktop/Kelly/wham_9.19')
runApp('~/Desktop/Kelly/wham_9.19')
runApp('~/Desktop/Kelly/wham_9.19')
runApp('~/Desktop/Kelly/wham_9.19')
runApp('~/Desktop/Kelly/wham_9.19')
runApp('~/Desktop/Kelly/wham_9.19')
runApp('~/Desktop/Kelly/wham_9.19')
runApp('~/Desktop/Kelly/wham_9.19')
runApp('~/Desktop/Kelly/wham_9.19')
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
